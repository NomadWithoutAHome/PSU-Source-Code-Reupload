--[[
	id: -OSCUyf23A9TOUj5nrihS
	name: box ind 
	description: self
	time1: 2021-06-27 16:12:28.299313+00
	time2: 2021-06-27 16:12:28.299314+00
	uploader: pEEVas8a9N2NseZaXKmKU6tL2Ns3ytyii6Rc7ZgP
	uploadersession: egrNjPP6xBdUc5us4JW9kPKQIse5TZ
	flag: f
--]]

local anti_aim = require 'gamesense/antiaim_funcs'
local csgo_weapons = require("gamesense/csgo_weapons") 
--local variables for API. Automatically generated by https://github.com/simpleavaster/gslua/blob/master/authors/sapphyrus/generate_api.lua 
local client_latency, client_log, client_draw_rectangle, client_draw_circle_outline, client_userid_to_entindex, client_draw_indicator, client_draw_gradient, client_set_event_callback, client_screen_size, client_eye_position = client.latency, client.log, client.draw_rectangle, client.draw_circle_outline, client.userid_to_entindex, client.draw_indicator, client.draw_gradient, client.set_event_callback, client.screen_size, client.eye_position 
local client_draw_circle, client_color_log, client_delay_call, client_draw_text, client_visible, client_exec, client_trace_line, client_set_cvar = client.draw_circle, client.color_log, client.delay_call, client.draw_text, client.visible, client.exec, client.trace_line, client.set_cvar 
local client_world_to_screen, client_draw_hitboxes, client_get_cvar, client_draw_line, client_camera_angles, client_draw_debug_text, client_random_int, client_random_float = client.world_to_screen, client.draw_hitboxes, client.get_cvar, client.draw_line, client.camera_angles, client.draw_debug_text, client.random_int, client.random_float 
local entity_get_local_player, entity_is_enemy, entity_hitbox_position, entity_get_player_name, entity_get_steam64, entity_get_bounding_box, entity_get_all, entity_set_prop = entity.get_local_player, entity.is_enemy, entity.hitbox_position, entity.get_player_name, entity.get_steam64, entity.get_bounding_box, entity.get_all, entity.set_prop 
local entity_is_alive, entity_get_player_weapon, entity_get_prop, entity_get_players, entity_get_classname = entity.is_alive, entity.get_player_weapon, entity.get_prop, entity.get_players, entity.get_classname 
local globals_realtime, globals_absoluteframetime, globals_tickcount, globals_curtime, globals_mapname, globals_tickinterval, globals_framecount,globals_maxplayers = globals.realtime, globals.absoluteframetime, globals.tickcount, globals.curtime, globals.mapname, globals.tickinterval, globals.framecount,  globals.maxplayers 
local ui_new_slider, ui_new_combobox, ui_reference, ui_set_visible, ui_is_menu_open, ui_new_color_picker, ui_set_callback, ui_set, ui_new_checkbox, ui_new_hotkey, ui_new_button, ui_new_multiselect, ui_get = ui.new_slider, ui.new_combobox, ui.reference, ui.set_visible, ui.is_menu_open, ui.new_color_picker, ui.set_callback, ui.set, ui.new_checkbox, ui.new_hotkey, ui.new_button, ui.new_multiselect, ui.get 
local math_ceil, math_tan, math_log10, math_randomseed, math_cos, math_sinh, math_random, math_huge, math_pi, math_max, math_atan2, math_ldexp, math_floor, math_sqrt, math_deg, math_atan, math_fmod = math.ceil, math.tan, math.log10, math.randomseed, math.cos, math.sinh, math.random, math.huge, math.pi, math.max, math.atan2, math.ldexp, math.floor, math.sqrt, math.deg, math.atan, math.fmod 
local math_acos, math_pow, math_abs, math_min, math_sin, math_frexp, math_log, math_tanh, math_exp, math_modf, math_cosh, math_asin, math_rad = math.acos, math.pow, math.abs, math.min, math.sin, math.frexp, math.log, math.tanh, math.exp, math.modf, math.cosh, math.asin, math.rad 
local table_maxn, table_foreach, table_sort, table_remove, table_foreachi, table_move, table_getn, table_concat, table_insert = table.maxn, table.foreach, table.sort, table.remove, table.foreachi, table.move, table.getn, table.concat, table.insert 
local string_find, string_format, string_rep, string_gsub, string_len, string_gmatch, string_dump, string_match, string_reverse, string_byte, string_char, string_upper, string_lower, string_sub = string.find, string.format, string.rep, string.gsub, string.len, string.gmatch, string.dump, string.match, string.reverse, string.byte, string.char, string.upper, string.lower, string.sub 
--end of local variables 


local ffi = require 'ffi'

pClientEntityList = client.create_interface("client_panorama.dll", "VClientEntityList003") or error("invalid interface", 2)
fnGetClientEntity = vtable_thunk(3, "void*(__thiscall*)(void*, int)")

ffi.cdef('typedef struct { float x; float y; float z; } bbvec3_t;')

local fnGetAttachment = vtable_thunk(83, "bool(__thiscall*)(void*, int, bbvec3_t&)")
local fnGetMuzzleAttachmentIndex1stPerson = vtable_thunk(467, "int(__thiscall*)(void*, void*)")
local fnGetMuzzleAttachmentIndex3stPerson = vtable_thunk(468, "int(__thiscall*)(void*)")

local get_attachment_vector = function(world_model)
    local me = entity.get_local_player()
    local wpn = entity.get_player_weapon(me)

    local model =
        world_model and 
        entity.get_prop(wpn, 'm_hWeaponWorldModel') or
        entity.get_prop(me, 'm_hViewModel[0]')
    if me == nil or wpn == nil then
        return
    end

    local active_weapon = fnGetClientEntity(pClientEntityList, wpn)
    local g_model = fnGetClientEntity(pClientEntityList, model)

    if active_weapon == nil or g_model == nil then
        return
    end

    local attachment_vector = ffi.new("bbvec3_t[1]")
    local att_index = world_model and
        fnGetMuzzleAttachmentIndex3stPerson(active_weapon) or
        fnGetMuzzleAttachmentIndex1stPerson(active_weapon, g_model)
    
    if att_index > 0 and fnGetAttachment(g_model, att_index, attachment_vector[0]) then
        return { attachment_vector[0].x, attachment_vector[0].y, attachment_vector[0].z }
    end
end

local clamp = function(v, min, max)
	local num = v

	num = num < min and min or num
	num = num > max and max or num

	return num
end
local global_alpha = 0
local global_alpha1 = 0
local global_alpha2 = 0
local ref_hs, ref_hs_key = ui_reference("AA", "Other", "On shot anti-aim")
local ref_dt, ref_dt_key = ui_reference("rage", "Other", "Double tap")
local ref_baim, ref_baim_key = ui_reference("rage", "Other", "Force body aim")
local ref_sp, ref_sp_key = ui_reference("rage", "Aimbot", "Force safe point")
local prefersp = ui_reference("rage", "Aimbot", "Prefer safe point")
local preferBaim = ui_reference("rage", "Other", "Prefer body aim")
local flip = 1
local third,third_hotkey = ui.reference("Visuals","Effects","Force third person (alive)")
local onshotstatus = "Ez1337"
local dtshotstatus = "Ez1338"
local aimpoint_distance = 10000
local enable = ui.new_checkbox("Config","presets","Legend Box")
local enableclr = ui.new_color_picker("Config","presets","Legend Box",255,255,255,255)
local xfw,yfw = client.screen_size()
xfw = xfw/2
yfw = yfw/2
local pos = ui.new_checkbox("Config","presets","Change Box ind position(debug)")
local fade_time = ui.new_slider("Config","presets", 'Animation speed', 4, 20, 12, true, 'fr', 1, { [4] = 'Off' })
local xez = ui.new_slider("Config","presets", 'X offset', -xfw, xfw, 0)
local yez = ui.new_slider("Config","presets", 'Y offset', -yfw, yfw, 0)
local iqez = ui.new_slider("Config","presets", '\a54AFFFFFIQ offset', 0,12, 0)
local tkez = ui.new_slider("Config","presets", '\a54AFFFFFTHICKNESS offset', 0,2,0)
--local leftbox = ui.new_checkbox("Config","presets","Main Weapon on left")
--local yaw_prev, pitch_prev = 0, 0


local function lerp(v1, v2, percentage)
	return (1-percentage)*v1 + percentage*v2 -- Linear Interpolation
end

local function distance(x1, y1, x2, y2)
	return math_sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1))
end



local Colors = {
    { 255, 0, 0 },
    { 237, 27, 3 },
    { 235, 63, 6 },
    { 229, 104, 8 },
    { 228, 126, 10 },
    { 220, 169, 16 },
    { 213, 201, 19 },
    { 176, 205, 10 },
    { 124, 195, 13 }
}

local math_num = function(int, max, declspec)
    local int = (int > max and max or int)
    local tmp = max / int;

    if not declspec then declspec = max end

    local i = (declspec / tmp)
    i = (i >= 0 and math.floor(i + 0.5) or math.ceil(i - 0.5))

    return i
end

local get_color = function(number, max)
    local i = math_num(number, max, #Colors)

    return
        Colors[i <= 1 and 1 or i][1], 
        Colors[i <= 1 and 1 or i][2],
        Colors[i <= 1 and 1 or i][3],
        i
end

local function get_MinDMG()
    local dmgMin = ui.reference("rage", "aimbot", "Minimum damage")
    local dmg = ui.get(dmgMin)
    if dmg == nil then return 0 end
     if dmg > 0 then
         return dmg
     end
     return 0
 end

 local function getP(str)
	local iq = string.format("%#x",str)
	local iqq  = string.sub(iq,-2) 
local iqqq =  string.upper(iqq)
return iqqq
end
local aaez = 255

client_set_event_callback("run_command", function()


if aaez >= 255 or aaez <= 40 then
	flip = flip * -1
end

aaez = math_min(math_max(aaez+ flip*2, 0), 255)


end)


local function circle_box( x,y,w,h,r,g,b,a,iq,thickness)
	if w < 0 then error("w must be > 0")
		return end
		if h < 0 then error("h must be > 0")
			return end
			if iq > w / 2 or iq > h / 2  then error("iq must be < w / 2 and iq must be > h / 2")
				return end
				--renderer.rectangle(x - w / 2 + iq, y, x + w / 2 - iq, y, r,g,b,a)--------top
	renderer.rectangle(x - w / 2 + iq, y,  w  - iq*2, thickness, r,g,b,255)--------top
	renderer.rectangle(x - w / 2 , y + iq, thickness,  h - iq * 2, r,g,b,255)-------left
	renderer.rectangle(x - w / 2 + iq, y + h ,  w  - iq * 2, -thickness, r,g,b,255)-------buttom
	renderer.rectangle(x + w / 2, y + iq, -thickness, h - iq * 2, r,g,b,255)-------right
	
	renderer.circle_outline(x - w / 2 + iq, y + iq, r,g,b,255, iq, 180, 0.25, thickness)---LEFT TOP
	renderer.circle_outline(x - w / 2 + iq, y + h - iq, r,g,b,255, iq, 90, 0.25, thickness)---left buttom
	renderer.circle_outline(x + w / 2 - iq, y + h - iq, r,g,b,255, iq, 0, 0.25, thickness)---right buttom
	renderer.circle_outline(x + w / 2 - iq, y + iq, r,g,b,255, iq, 270, 0.25, thickness)---right top

	renderer.rectangle(x - w / 2+iq,y+thickness,w-iq*2,h - thickness*2,15,15,15,a)
	renderer.rectangle(x-w/2+thickness,y+iq,iq-thickness,h-iq*2,15,15,15,a)
	renderer.rectangle(x+w/2-iq,y+iq,iq-thickness,h-iq*2,15,15,15,a)
	renderer.circle(x - w / 2 + iq, y + iq, 15,15,15,a, iq-thickness, 180, 0.25)
	renderer.circle(x + w / 2 - iq, y + h - iq, 15,15,15,a, iq-thickness, 0, 0.25)
	renderer.circle(x + w / 2 - iq, y + iq, 15,15,15,a, iq-thickness, 90, 0.25)
	renderer.circle(x - w / 2 + iq, y + h - iq, 15,15,15,a, iq-thickness, 270, 0.25)
end





local function on_paint(ctx)

	ui.set_visible(enableclr,ui.get(enable))
	ui.set_visible(pos,ui.get(enable))
	ui.set_visible(xez,ui.get(enable) and ui.get(pos))
	ui.set_visible(yez,ui.get(enable)and ui.get(pos))
	ui.set_visible(fade_time,ui.get(enable)and ui.get(pos))
	ui.set_visible(iqez,ui.get(enable) and ui.get(pos))
	ui.set_visible(tkez,ui.get(enable)and ui.get(pos))
	--ui.set_visible(leftbox,ui.get(enable))
	local local_player = entity.get_local_player()
	local weapon_ent = entity.get_player_weapon(local_player)
	if weapon_ent == nil then return end

	-- calling csgo_weapons with an entindex returns the weapon data for that entity
	local weapon = csgo_weapons(weapon_ent)
	if weapon == nil then return end

	-- alternatively you can get the data using the item definition index like this
	local weapon_idx = entity.get_prop(weapon_ent, "m_iItemDefinitionIndex")
	local weapon = csgo_weapons[weapon_idx]
	if weapon_ent == nil then return end
	if weapon.type == "knife" or  weapon.type == "c4" or  weapon.type == "grenade" then	return end
local n = 0
local s = 0
local b = 0
if weapon.type == "pistol" then
	n = 20
else
	n = 0
end
if weapon.name == "AWP" then
	s = 10
else	
	s = 0
end

if weapon.name == "SCAR-20" or weapon.name == "G3SG1" then
	b = 10
else	
	b = 0
end




	local rez,gez,bez,aez = ui.get(enableclr)
	if not ui.get(enable) then
		return
	end
	if ui.get(ref_hs) and ui.get(ref_hs_key) then
		onshotstatus = "ON"
		ref_r = 0
		ref_g = 235
		ref_b = 0
	 else
		onshotstatus = "OFF"
		ref_r = 255
		ref_g = 0
		ref_b = 0
	 end
	
	 if ui.get(ref_dt) and ui.get(ref_dt_key) then
		dtstatus = "ON"
		reff_r = 0
		reff_g = 235
		reff_b = 0
	 else
		dtstatus = "OFF"
		reff_r = 255
		reff_g = 0
		reff_b = 0
	 end




	local local_player = entity_get_local_player()

     if local_player == nil then
		return
	 end
	local aim_punch_angle_pitch, aim_punch_angle_yaw = entity_get_prop(local_player, "m_aimPunchAngle")
	--local view_punch_angle_pitch, view_punch_angle_yaw = entity_get_prop(local_player, "m_viewPunchAngle")

	local weapon = entity_get_player_weapon(local_player)
	local weapon_name = entity_get_classname(weapon)

	--ghetto fix to not show recoil crosshair for snipers




	local x, y, z = entity_get_prop(local_player, "m_vecAbsOrigin")
	z = z + entity_get_prop(local_player, "m_vecViewOffset[2]")
	local pitch, yaw = client_camera_angles()
	local aim_punch_angle_pitch, aim_punch_angle_yaw = entity_get_prop(local_player, "m_aimPunchAngle")


		--aim_punch_angle_pitch = 0
		--aim_punch_angle_yaw = 0
		
		local a_multiplier = 1
		local recoil_amount = distance(0, 0, math_abs(aim_punch_angle_pitch), math_abs(aim_punch_angle_yaw))



		local recoil_scale = client_get_cvar("weapon_recoil_scale")
		
		aim_punch_angle_pitch = aim_punch_angle_pitch*recoil_scale
		aim_punch_angle_yaw = aim_punch_angle_yaw*recoil_scale

		yaw = yaw - 180

		yaw = math_rad(yaw+aim_punch_angle_yaw)
		pitch = math_rad(pitch+aim_punch_angle_pitch)

		--yaw, pitch = lerp(yaw, yaw_prev, 0.5), lerp(pitch, pitch_prev, 0.5)

		local xTarget = x - math_cos(yaw) * aimpoint_distance
		local yTarget = y - math_sin(yaw) * aimpoint_distance
		local zTarget = z - math_tan(pitch) * aimpoint_distance

		local predicted_pos = {}
		local lp = entity.get_local_player()
		local weap = entity.get_player_weapon(lp)
		local x,y,z = client.eye_position()
		local vel = {entity.get_prop(lp, "m_vecVelocity")}

		local idx = entity.get_prop(entity.get_player_weapon(lp), "m_iItemDefinitionIndex")
		local speed = 215
		local poswp = get_attachment_vector(false)
		wxx, wyy = renderer.world_to_screen(poswp[1], poswp[2], poswp[3])
		local slider = 32
		local flags = entity.get_prop(entity.get_local_player(), "m_fFlags")
		local lower_body = anti_aim.get_balance_adjust()
		local next_update = lower_body.next_update-globals.curtime()
		local gr = lower_body.updating and next_update > 0
		local camera_angles = { client.camera_angles() }
		local by = anti_aim.normalize_angle(camera_angles[2] - anti_aim.get_body_yaw(1) - 120)
		local fy = anti_aim.normalize_angle(camera_angles[2] - anti_aim.get_body_yaw(2) - 120)
		local delta = math.abs(math.floor(anti_aim.get_desync(1)))
		local re, ge, be = get_color(math.abs(anti_aim.get_desync(1)), 28)

		local pxx,pyy = client.screen_size()
		pxx = pxx / 2 
		wxx = wxx + s * 1.5
		wyy = wyy + s / 2 

		--if ui.get(leftbox)  then
			--wx = wxx + n
			--wy = wyy - 40
		--else
		local iqx = 0
		local iqy = 0
		if ui.get(pos) then
			 iqx = ui.get(xez)
			 iqy = ui.get(yez)
		else
			iqx = 0
			iqy = 0
		end
			wx = wxx +  60 - n - b*36 + iqx
			wy = wyy - 160 + b * 3 + iqy
		--end
		if wx ~= nil then
			local fade_time = ui.get(fade_time)
		local sb = 0
		local globals_frametime = globals.frametime
		local FT = fade_time > 4 and (globals_frametime()*fade_time/5) or 1
		local FT2 = fade_time > 4 and (globals_frametime()*fade_time/100) or 1
		--	if is_valid and scope_level > 0 and scoped and not resume_zoom then
		--		sb = clamp(sb+FT, 0, 1)
			--else
			--	sb = clamp(sb-FT, 0, 1)
			--end
			if ui.get(third) and not ui.get(third_hotkey) then 
				local qez = 0
				local dtez = 0
				local spez = 0
				local baimez = 0
				if ui.get(ref_dt) and ui.get(ref_dt_key) then

					global_alpha = clamp(global_alpha+FT, 0, 1)
					global_alphadt = clamp(global_alpha+FT2, 0.5, 1)
					--renderer.text(qx+35, qy+100+qez, 215, 215, 215, 255, "", 255, "",'\a54AFFFFFT\a5CAFFEFFi\a65AFFEFFc\a6DAFFDFFk\a76AFFDFFB\a7EAFFCFFa\a87AFFCFFs\a8FAFFCFFe\aA0AFFBFFS\aA9AFFAFFh\aB2AFFAFFi\aBAAFFAFFf\aC3AFF9FFt\aCBAFF9FFi\aD4AFF8FFn\aDCAFF8FFg\aE5AFF8FF.\aEDAFF7FF.\aF6AFF7FF.')
					dtez = dtez + 15
				 else
					global_alpha = clamp(global_alpha-FT, 0, 1)
					global_alphadt = clamp(global_alpha-FT2, 0.5, 1)
					dtez = dtez + 15
				 end
				 if ui.get(prefersp) and not ui.get(ref_sp)  then
					--renderer.text(qx+35, qy+100+qez, 215, 215, 215, 255, "c", 0, "testpresp")
					qez = qez + 15
				 else
					qez = qez
				 end
				 if ui.get(preferBaim) and not ui.get(ref_baim)  then
					qez = qez + 15
				 else
					qez = qez
				 end
				 if ui.get(ref_sp) then
					global_alpha1 = clamp(global_alpha1+FT, 0, 1)
					global_alpha1s = clamp(global_alpha1+FT2, 0, 1)
					spez = spez + 15
				 else
					global_alpha1 = clamp(global_alpha1-FT, 0, 1)
					global_alpha1s = clamp(global_alpha1-FT2, 0, 1)
					spez = spez + 15
				 end
				 if ui.get(ref_baim) then
					global_alpha2 = clamp(global_alpha2+FT, 0, 1)
					global_alpha2b = clamp(global_alpha2+FT2, 0, 1)
					baimez = baimez + 15
				 else
					global_alpha2 = clamp(global_alpha2-FT, 0, 1)
					global_alpha2b = clamp(global_alpha2-FT2, 0, 1)
					baimez = baimez + 15
				 end
				 
				local Oez = 0
				--if	ui.get(ref_dt) and ui.get(ref_dt_key) or ui.get(preferBaim) and not ui.get(ref_baim) or ui.get(preferBaim) and not ui.get(ref_baim) or ui.get(prefersp) and not ui.get(ref_sp) or ui.get(ref_sp) then
				--global_alpha = clamp(global_alpha+FT, 0, 1)
				--else
				--	global_alpha = clamp(global_alpha-FT, 0, 1)
				--end

					--renderer.rectangle(wx+20+20, wy, 200, 2, rez,gez,bez, 255)
					local iq = ui.get(iqez) + 20
					local thickness = ui.get(tkez) + 3
					circle_box(wx+20+20+95, wy+2, 200, 91+qez+dtez*global_alpha+spez*global_alpha1+baimez*global_alpha2,rez,gez,bez,aez,iq,thickness)
					
					if weapon_name == "CWeaponSCAR20" or weapon_name == "CWeaponG3SG1"  then
					renderer.line(wxx+10 - b*1.9,wyy-2,wx+40+200-iq/math.sqrt(2)+6.5,wy+81+qez+dtez*global_alpha+spez*global_alpha1+baimez*global_alpha2+2,rez,gez,bez,255)
					else
					renderer.line(wxx+8,wyy-2,wx+42,wy+87+qez+dtez*global_alpha+spez*global_alpha1+baimez*global_alpha2,rez,gez,bez,255)
					end
					renderer.circle_outline(wxx, wyy, rez,gez,bez, 255, 10, 0, 1, 2)
					--renderer.line(wxx,wyy,wx+240,wy+2+(81+qez)/5*1,rez,gez,bez,255)
					--renderer.line(wxx,wyy,wx+240,wy+2+(81+qez)/5*2,rez,gez,bez,255)
					--renderer.line(wxx,wyy,wx+240,wy+2+(81+qez)/5*3,rez,gez,bez,255)
					--renderer.line(wxx,wyy,wx+240,wy+2+(81+qez)/5*4,rez,gez,bez,255)
					--renderer.line(wxx,wyy,wx+240,wy+2+81+qez,rez,gez,bez,255)
					--renderer.triangle(wxx-7,wyy, wx+240,wy+1,wx+240,wy+2+81+qez, 15, 15, 15, aez)
					local sez = 0
					if iq == 1 then
						sez = 0
					else
						sez = iq/4
					end
					wx = wx + sez
					wy = wy + thickness
					local dtalphaez = getP(aaez*global_alphadt)
					local spalphaez = getP(255*global_alpha1s)
					local bmalphaez = getP(255*global_alpha2b)
					if ui.get(ref_dt) and ui.get(ref_dt_key) then
						renderer.text(wx+20+20+100, wy+85+Oez, 0,0,0,0, "c", 255, "",'\a54AFFF'..dtalphaez..'T\a5CAFFE'..dtalphaez..'i\a65AFFE'..dtalphaez..'c\a6DAFFD'..dtalphaez..'k\a76AFFD'..dtalphaez..'B\a7EAFFC'..dtalphaez..'a\a87AFFC'..dtalphaez..'s\a8FAFFC'..dtalphaez..'e\aA0AFFB'..dtalphaez..'S\aA9AFFA'..dtalphaez..'h\aB2AFFA'..dtalphaez..'i\aBAAFFA'..dtalphaez..'f\aC3AFF9'..dtalphaez..'t\aCBAFF9'..dtalphaez..'i\aD4AFF8'..dtalphaez..'n\aDCAFF8'..dtalphaez..'g\aE5AFF8'..dtalphaez..'.\aEDAFF7'..dtalphaez..'.\aF6AFF7'..dtalphaez..'.')
						Oez = Oez + 15
					else
						Oez = Oez 
					 end
					 if ui.get(prefersp) and not ui.get(ref_sp)  then
						renderer.text(wx+20+20+100, wy+85+Oez*global_alpha, 215, 215, 215, 255, "c", 255, "",'\a45FF51FFP\a41F35CFFR\a3EE768FFE\a3BDB73FFF\a38CF7FFFE\a35C38AFFR \a32B796FFS\a2FABA2FFA\a2CA0ADFFF\a2994B9FFE\a2688C4FFP\a237CD0FFO\a2070DCFFI\a1D64E7FFN\a1A58F3FFT')
						Oez = Oez + 15
					 else
						Oez = Oez 
					 end
					 if ui.get(preferBaim) and not ui.get(ref_baim)  then
						renderer.text(wx+20+20+100, wy+85+Oez, 215, 215, 215, 255, "c", 255, "",'\aFF1C1CFFP\aEF242CFFR\aDF2D3CFFE\aD0364CFFF\aC03F5CFFE\aB0486DFFR \a915A8DFFB\a81639DFFo\a726CADFFd\a6275BEFFy\a527ECEFFa\a4387DEFFi\a3390EEFFm')
						Oez = Oez + 15
					 else
						Oez = Oez 
					 end
					 if ui.get(ref_sp) then
						renderer.text(wx+20+20+100, wy+85+Oez, 215, 215, 215, 255, "c", 255, "",'\a45FF51'..spalphaez..'F\a41F35C'..spalphaez..'O\a3EE768'..spalphaez..'R\a3BDB73'..spalphaez..'C\a35C38A'..spalphaez..'E \a32B796'..spalphaez..'S\a2FABA2'..spalphaez..'A\a2CA0AD'..spalphaez..'F\a2994B9'..spalphaez..'E\a2688C4'..spalphaez..'P\a237CD0'..spalphaez..'O\a2070DC'..spalphaez..'I\a1D64E7'..spalphaez..'N\a1A58F3'..spalphaez..'T')
						Oez = Oez + 15
					 else
						Oez = Oez 
					 end
					 if ui.get(ref_baim) then
						renderer.text(wx+20+20+100, wy+85+Oez, 215, 215, 215, 255, "c", 255, "",'\aFF1C1C'..bmalphaez..'F\aEF242C'..bmalphaez..'O\aDF2D3C'..bmalphaez..'R\aD0364C'..bmalphaez..'C\aB0486D'..bmalphaez..'E \a915A8D'..bmalphaez..'B\a81639D'..bmalphaez..'o\a726CAD'..bmalphaez..'d\a6275BE'..bmalphaez..'y\a527ECE'..bmalphaez..'a\a4387DE'..bmalphaez..'i\a3390EE'..bmalphaez..'m')
						Oez = Oez + 15
					 else
						Oez = Oez 
					 end
		

					 



					renderer.text(wx+20+20, wy+5, 215, 215, 215, 255, "-",0 , "1z ANTI-AIMBOTDEBUG")
					renderer.circle_outline(wx+180+20, wy+15+5, 15, 15, 15, 180, 10.5, 0, 1, 2)
					renderer.circle_outline(wx+180+20, wy+15+5, 150, 150, 150, 255, 10.5, by, 0.05, 2)
					renderer.circle_outline(wx+180+20, wy+15+5, rez,gez,bez, 255, 10.5, fy, 0.1, 2)
					
					
					renderer.gradient(wx+28+20, wy+33, 2.5, 7, re, ge, be, 255, re, ge, be, 50, false)
					renderer.gradient(wx+28+20, wy+33, 2.5, -7, re, ge, be, 255, re, ge, be, 50, false)
					if not gr then
					renderer.text(wx+35+20, wy+27, 215, 215, 215, 255, "b", 0, "FAKE (" .. delta.." ° )")
					else
						renderer.circle_outline(wx+40+20, wy+33,0,255,255,255,5,360, next_update / 1.1 * 1,2)
						renderer.text(wx+55+20, wy+27, 215, 215, 215, 255, "b", 0, "FAKE (" .. delta.." ° )")
					end
				
				local dg = math.abs(anti_aim.get_desync(1))
				dg = dg/3
				renderer.text(wx+25+20, wy+55, 215, 215, 215, 255, "-", 0, "SP")
				renderer.rectangle(wx+45+20, wy+60, 20, 4, 0, 0, 0, 200)
				renderer.rectangle(wx+70+20, wy+60, 20, 4, 0, 0, 0, 200)
				renderer.rectangle(wx+45+20, wy+60, dg, 4, rez,gez,bez, 255)
				renderer.rectangle(wx+70+20, wy+60, 20-dg, 4, rez,gez,bez, 255)
				local dmg = get_MinDMG()
				renderer.text(wx+70+20+50+10,wy+60,rez,gez,bez,255,"c",0,"DMG : "..dmg)
	
	
				renderer.text(wx+190, wy+55, 215, 215, 215, 255, "-", 0, "OS :")
				renderer.text(wx+205, wy+55, ref_r,ref_g,ref_b, 255, "-", 0, " " ..onshotstatus)
			
				end	 
			end
		
end
		--if math_abs(yaw-yaw_prev) > 0.002 and math_abs(pitch-pitch_prev) > 0.002 then
		--	yaw_prev, pitch_prev = yaw, pitch
		--end

client.set_event_callback("paint", on_paint)




local function on_paint2(ctx)
	local rez,gez,bez,aez = ui.get(enableclr)
	if not ui.get(enable) then
		return
	end
	if ui.get(ref_hs) and ui.get(ref_hs_key) then
		onshotstatus = "ON"
		ref_r = 0
		ref_g = 235
		ref_b = 0
	 else
		onshotstatus = "OFF"
		ref_r = 255
		ref_g = 0
		ref_b = 0
	 end
	
	 if ui.get(ref_dt) and ui.get(ref_dt_key) then
		dtstatus = "ON"
		reff_r = 0
		reff_g = 235
		reff_b = 0
	 else
		dtstatus = "OFF"
		reff_r = 255
		reff_g = 0
		reff_b = 0
	 end




	local local_player = entity_get_local_player()

     if local_player == nil then
		return
	 end
	local aim_punch_angle_pitch, aim_punch_angle_yaw = entity_get_prop(local_player, "m_aimPunchAngle")
	--local view_punch_angle_pitch, view_punch_angle_yaw = entity_get_prop(local_player, "m_viewPunchAngle")

	local weapon = entity_get_player_weapon(local_player)
	local weapon_name = entity_get_classname(weapon)

	--ghetto fix to not show recoil crosshair for snipers




	local x, y, z = entity_get_prop(local_player, "m_vecAbsOrigin")
	z = z + entity_get_prop(local_player, "m_vecViewOffset[2]")
	local pitch, yaw = client_camera_angles()
	local aim_punch_angle_pitch, aim_punch_angle_yaw = entity_get_prop(local_player, "m_aimPunchAngle")


		--aim_punch_angle_pitch = 0
		--aim_punch_angle_yaw = 0
		
		local a_multiplier = 1
		local recoil_amount = distance(0, 0, math_abs(aim_punch_angle_pitch), math_abs(aim_punch_angle_yaw))



		local recoil_scale = client_get_cvar("weapon_recoil_scale")
		
		aim_punch_angle_pitch = aim_punch_angle_pitch*recoil_scale
		aim_punch_angle_yaw = aim_punch_angle_yaw*recoil_scale

		yaw = yaw - 180

		yaw = math_rad(yaw+aim_punch_angle_yaw)
		pitch = math_rad(pitch+aim_punch_angle_pitch)

		--yaw, pitch = lerp(yaw, yaw_prev, 0.5), lerp(pitch, pitch_prev, 0.5)

		local xTarget = x - math_cos(yaw) * aimpoint_distance
		local yTarget = y - math_sin(yaw) * aimpoint_distance
		local zTarget = z - math_tan(pitch) * aimpoint_distance

		local predicted_pos = {}
		local lp = entity.get_local_player()
		local weap = entity.get_player_weapon(lp)
		local x,y,z = client.eye_position()
		local vel = {entity.get_prop(lp, "m_vecVelocity")}

		local idx = entity.get_prop(entity.get_player_weapon(lp), "m_iItemDefinitionIndex")
		local speed = 215

		local slider = 32
		local flags = entity.get_prop(entity.get_local_player(), "m_fFlags")
		local lower_body = anti_aim.get_balance_adjust()
		local next_update = lower_body.next_update-globals.curtime()
		local gr = lower_body.updating and next_update > 0
		local camera_angles = { client.camera_angles() }
		local by = anti_aim.normalize_angle(camera_angles[2] - anti_aim.get_body_yaw(1) - 120)
		local fy = anti_aim.normalize_angle(camera_angles[2] - anti_aim.get_body_yaw(2) - 120)
		local delta = math.abs(math.floor(anti_aim.get_desync(1)))
		local re, ge, be = get_color(math.abs(anti_aim.get_desync(1)), 28)



	
	if ui.get(third) and  ui.get(third_hotkey) then 
		local predicted_pos = {}
		local lp = entity.get_local_player()
		local weap = entity.get_player_weapon(lp)
		local x,y,z = client.eye_position()
		local vel = {entity.get_prop(lp, "m_vecVelocity")}
		local speed = 215
		local idx = entity.get_prop(entity.get_player_weapon(lp), "m_iItemDefinitionIndex")
		local xxx,yyy,zzz = entity.hitbox_position(lp,4)
		local slider = 32
		local flags = entity.get_prop(entity.get_local_player(), "m_fFlags")
if flags == 256 then
	 x3,y3,z3 = xxx,yyy,zzz
	else
 x3,y3,z3 = xxx,yyy,zzz
	end
local qxx,qyy = renderer.world_to_screen(x3, y3, z3)
local deltaP = math.floor(anti_aim.get_desync(1))
if qyy == nil then
	qyy = 1
end
if qxx == nil then
	qxx = 1
end
if flags == 256 then
	qx,qy = renderer.world_to_screen(x3+(vel[1] / speed) * 0.05, y3+(vel[2] / speed) * 0.05, z3+(vel[3] / speed) * 0.005)
	else
	qx,qy = renderer.world_to_screen(x3+(vel[1] / speed) * 4, y3+(vel[2] / speed) * 4, z3+(vel[3] / speed) * 2)
	end

if qy == nil then
	qy = 1
end
if qx == nil then
	qx = 1
end


local pez = 0

if ui.get(ref_dt) and ui.get(ref_dt_key) then
		
	
	pez = pez + 15
 else
	pez = pez
 end
 if ui.get(prefersp) and not ui.get(ref_sp)  then

	pez = pez + 15
 else
	pez = pez
 end
 if ui.get(preferBaim) and not ui.get(ref_baim)  then
	pez = pez + 15
 else
	pez = pez
 end
 if ui.get(ref_sp) then
	pez = pez + 15
 else
	pez = pez
 end
 if ui.get(ref_baim) then
	pez = pez + 15
 else
	pez = pez
 end
 local iq = ui.get(iqez) + 20
 local thickness = ui.get(tkez) + 3
 circle_box(qx+105 ,qy+35 ,220 ,10+81+pez,rez,gez,bez,aez,iq,thickness)
 local sez = 0
 if iq == 1 then
	 sez = 0
 else
	 sez = iq/4
 end
 qx = qx + sez
 qy = qy + thickness
--renderer.rectangle(qx ,qy+37 ,200 ,81+pez,15, 15, 15, aez)
renderer.circle_outline(qxx,qyy,rez,gez,bez, 255, 5, 0, 1, 2)
renderer.line(qxx+math.sqrt(5),qyy+math.sqrt(5),qx,qy+35,rez,gez,bez, 255)
renderer.text(qx ,qy+37, 215, 215, 215, 255, "-",0 , "1z ANTI-AIMBOTDEBUG")
renderer.circle_outline(qx+180 ,qy+37+13, 15, 15, 15, 180, 10.5, 0, 1, 2)
renderer.circle_outline(qx+180 ,qy+37+13, 255, 255, 255, 255, 10.5, by, 0.05, 2)
renderer.circle_outline(qx+180 ,qy+37+13, rez,gez,bez, 255, 10.5, fy, 0.1, 2)
renderer.gradient(qx+8, qy+37+33, 2.5, 7, re, ge, be, 255, re, ge, be, 50, false)
renderer.gradient(qx+8, qy+37+33, 2.5, -7, re, ge, be, 255, re, ge, be, 50, false)
local Oez = 0
if ui.get(ref_dt) and ui.get(ref_dt_key) then
	renderer.text(qx+15, qy+115+Oez, 215, 215, 215, 255, "", 255, "",'\a54AFFFFFT\a5CAFFEFFi\a65AFFEFFc\a6DAFFDFFk\a76AFFDFFB\a7EAFFCFFa\a87AFFCFFs\a8FAFFCFFe\aA0AFFBFFS\aA9AFFAFFh\aB2AFFAFFi\aBAAFFAFFf\aC3AFF9FFt\aCBAFF9FFi\aD4AFF8FFn\aDCAFF8FFg\aE5AFF8FF.\aEDAFF7FF.\aF6AFF7FF.')
	Oez = Oez + 15
else
	Oez = Oez 
 end
 if ui.get(prefersp) and not ui.get(ref_sp)  then
	renderer.text(qx+15, qy+115+Oez, 215, 215, 215, 255, "", 255, "",'\a45FF51FFP\a41F35CFFR\a3EE768FFE\a3BDB73FFF\a38CF7FFFE\a35C38AFFR \a32B796FFS\a2FABA2FFA\a2CA0ADFFF\a2994B9FFE\a2688C4FFP\a237CD0FFO\a2070DCFFI\a1D64E7FFN\a1A58F3FFT')
	Oez = Oez + 15
 else
	Oez = Oez 
 end
 if ui.get(preferBaim) and not ui.get(ref_baim)  then
	renderer.text(qx+15, qy+115+Oez, 215, 215, 215, 255, "", 255, "",'\aFF1C1CFFP\aEF242CFFR\aDF2D3CFFE\aD0364CFFF\aC03F5CFFE\aB0486DFFR \a915A8DFFB\a81639DFFo\a726CADFFd\a6275BEFFy\a527ECEFFa\a4387DEFFi\a3390EEFFm')
	Oez = Oez + 15
 else
	Oez = Oez 
 end
 if ui.get(ref_sp) then
	renderer.text(qx+15, qy+115+Oez, 215, 215, 215, 255, "", 255, "",'\a45FF51FFF\a41F35CFFO\a3EE768FFR\a3BDB73FFC\a35C38AFFE \a32B796FFS\a2FABA2FFA\a2CA0ADFFF\a2994B9FFE\a2688C4FFP\a237CD0FFO\a2070DCFFI\a1D64E7FFN\a1A58F3FFT')
	Oez = Oez + 15
 else
	Oez = Oez 
 end
 if ui.get(ref_baim) then
	renderer.text(qx+15, qy+115+Oez, 215, 215, 215, 255, "", 255, "",'\aFF1C1CFFF\aEF242CFFO\aDF2D3CFFR\aD0364CFFC\aB0486DFFE \a915A8DFFB\a81639DFFo\a726CADFFd\a6275BEFFy\a527ECEFFa\a4387DEFFi\a3390EEFFm')
	Oez = Oez + 15
 else
	Oez = Oez 
 end








if not gr then
	renderer.text(qx+15, qy+37+27, 215, 215, 215, 255, "b", 0, "FAKE (" .. delta.." ° )")
	else
		renderer.circle_outline(qx+20, qy+37+33,185,185,255,255,5,360, next_update / 1.1 * 1,2)
		renderer.text(qx+35, qy+27+37, 215, 215, 215, 255, "b", 0, "FAKE (" .. delta.." ° )")
	end
	local dg = math.abs(anti_aim.get_desync(1))
	dg = dg/3
	renderer.text(qx+5, qy+37+55, 215, 215, 215, 255, "-", 0, "SP")
	renderer.rectangle(qx+25, qy+37+60, 20, 4, 0, 0, 0, 200)
	renderer.rectangle(qx+50, qy+37+60, 20, 4, 0, 0, 0, 200)
	renderer.rectangle(qx+25, qy+37+60, dg, 4, rez,gez,bez, 255)
	renderer.rectangle(qx+50, qy+37+60, 20-dg, 4, rez,gez,bez, 255)
	local dmg = get_MinDMG()
	renderer.text(qx+50+50+10,qy+37+60,rez,gez,bez,255,"c",0,"DMG : "..dmg)

		renderer.text(qx+150, qy+37+55, 215, 215, 215, 255, "-", 0, "OS :")
		renderer.text(qx+165, qy+37+55, ref_r,ref_g,ref_b, 255, "-", 0, " " ..onshotstatus)




end






end
client.set_event_callback("paint", on_paint2)



